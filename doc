=== NOTE ===
Dates are written as DD/MM/YYYY
============


Testing the cross compiler with the test mentioned in getting started pdf works

Added symbolic links from l4vcpu-rtems4.11-* to i386-rtems4.11-* in
/opt/rtems-4.11/bin

Added l4vcpu in c/src/aclocal/rtems-cpu-subdirs.m4

Added l4vcpu in config.sub around line 319, to the "i*86 | x86_64" option

--- above is critical -- 



Added symbolic link to wrapper_1.h in 
back_rtems/cpukit/score/cpu/l4vcpu/rtems/score/ 
and added the include in 'interrupts.h' in the same folder

Added wrapper_1.h file mentioned above in cpukit/score/cpu/l4vcpu/Makefile.am

--enable-maintainer-mode :
  Makefile.am changes will be written out to Makefile.in

add libl4rtems.a.o to l4vcpu-rtems4.11/pc386/lib/
results in more specific `undefined reference` errors

+++ TODO +++

  add in the l4 header files to complete the compile process!
    The cpukit/score/cpu/l4vcpu/rtems/l4 folder has to be created with an extra
      command. Or the make process will fail with 'no file or directory'.
      Or, the wrapper needs to be moved to ../l4vcpu/rtems/score/
    The include paths for the wrapper need to be fixed, so it can be cleanly
      included.


08/07/2012
The libl4rtems.o.a library needs to be linked completly in the l4 environment,
so there are no Undefined symbols left in the symbol table. 
There are various ways I to achieve this, but I don't know which one will work,
so I just list them:
* -z defs  //if shared_library undef symbols still allowed
// if shared:
* -Bstatic ++ -shared ++ --unresolved-symbols=report-all
* -Bsymbolic


WTF Moment of the hour!
src/l4/mk/lib.mk:78  :: LDSCRIPT_INCR ?= /dev/null
  so actually we do NOT have a incremental linker script? 


09/07/2012
l4rtems_outport / _inport / _out / _in
  * needs implementation
  * hooks in /c/src/lib/libcpu/l4vcpu/cpu.h
  => put impl in the library file or in the wrapper?

l4rtems_irq_restore / ++
  * implemented in wrapper_1.h but 'undefined reference' error
  => put impl in the library file? 
    * But functionality of the wrapper needed
    * How can I add the wrapper to the libl4rtems library?


10/07/2012

moving l4rtems_irq_disable_save as a dummy function to libl4rtems/l4rtems_io.c
and adding the function name to global.syms solves the undefined references,
but I can't use it there, because the l4_vcpu_state_t needs to be in the
wrapper_1.c file. I need to structure the code, so I can provide a library to
rtems and run it on l4re --> THinK!


12/07/2012

Through which interface does the vCPU-Guest (RTEMS) and the vCPU-Host (L4Re)
communicate?
When I link staticaly the l4rtems.o.a into RTEMS, I don't get the address of
my L4Re code. I get the address of the code linked into RTEMS and this code
doesn't have a connection to L4Re anymore. So how do I implement the vcpu-exit,
which is caught by the vCPU-handler on the host system?
Where do I place the exit reason? --> is_irq_entry() ->i()->label


What I should do:
Define a structure in L4Re to share with RTEMS during startup. To do this,
store the pointer to the structure in a vCPU register. As we are in the same
address space this works fine. I just have to include the libvcpu-header file,
so RTEMS knows the structure of the vCPU. As the shared structure grows, I have
to include more headers. But we will see that when the time is right.


14/12/2012

I added a shared variable structure to the RTEMS_wrapper and stored it in edx
of the vCPU. I isn't used in start.S directly and I hope I can extract the
pointer to this shared structure in bootcard with a litte bit of inline asm. 
But bootcard is shared over all BSPs so specific changes for one bsp should
NOT go in there.
It would be best practice to declare the sharedVar variable somewhere inside
the l4vcpuBsp and save the pointer at the beginning of the start.S file, as
this is BSP specific. How do I declare extern variables in ASM? Just with
"EXTERN _varname" or does this only work for functions?
And the second question is, where to store the variable in the first place.
Maybe it would be best to write a special file.

I already added custome functions for inport/outport in 
c/src/lib/libcpu/l4vcpu/cpu.h. I copied the old i386 methods back, so I can
focus on a more specific set of problems without side effects from linker
errors.
Result: Only a few 'undefined reference' errors remain

I removed the previously added libl4rtems.o.a from the build dir.
I also removed l4rtems_inch/_ouch from libbsp/l4vcpu/pc386/console/console.c
Now onyle the 'undefined reference to irq_disable/endable' errors remain.

I placed the sharedVariableStruct together with the wrapper_1.h include in the
pc386/startup/bspgeworkarea.c file and defined it extern in start/start.S.
==> I have a include problem, so the sharedvars_t is not recognised. 


15/07/2012

First thing on a sunday morning: 'typedef' seems to be a C++ construct and is
not recognized by RTEMS. I exchanged it with 'struct guestHostShare. Now it
compiles fine.

Now I move libvcpu/include/vcpu.h into the cpukit/score/rtems/l4vcpu tree and
include it in interrupts.h, as I need it for the enable/disable interrupt
functionality.
Due to this change I need all l4 dependencies in the RTEMS tree, which I
modified to only search for local headers and prefixed all with l4, so they
don't collide with RTEMS includes.
So now I got a complete set of necessary l4 includes, mostly from l4sys and
l4sys/ARCH_x86. I added and modified the includes of all files; l4utcb.h and
l4utcb_x86.h have been a bit tricky, as they depend on each other and the compiler
doesn't overwrite weak declarations. Additionally the l4_utcb_t is not found in
l4utcb_x86.h, so I copied it over.

Some errors bound to the change in interrupts.h still remain. 
>> error: dereferencing pointer to incomplete type
I think the declaration: 'extern struct guestHostShare *sharedVariableStruct'
is not working correctly. 

I needed to add the wrapper.h to the interrupts.h file and to include vcpu.h in
the wrapper.h.
I don't know how to handle the last two parameters of 'l4vcpu_irq_restore' -
'do_event_work_cb' and 'setup_ipc'. I just work with NULL for both of them, to keep
going.

Moved the 'l4rtems_vcpu_irq_state' to 'getbspworkarea.c' and declared it as
'extern' in interrupts.h, as it throws multiple definition errors.

And the added NULL value for 'setup_ipc' and 'do_event_work_cb' is already
falling on my feet...


16/07/2012

No it wasn't. The undefined reference to l4_ipc_wait was due to the missing
implementation file, as it's an architecture specific file. Additionally I need
to remove the header of l4_ipc_wait in l4ipc.h and add the include of
l4ipc-invoke-x86.h and l4ipc-l42-gcc3-nopic.h(order matters). 
This leads to an undefined reference of __l4sys_invoke_direct, which should be
provided by the linker itself in the linkerscript. 
L4Re provides it in ldscripts/generic.h as __l4sys_invoke_direct =
__L4_KIP_ADDR__ + 0x800. The __L4_KIP_ADDR__ is provided by the buildsystem in
l4/mk/prog.mk, which grabs the variable from l4/mk/Makeconf.
>> The question is: How do I get this address into RTEMS?


I need to implement the 'do_event_work_cb' and it should point to the RTEMS irq
handler, as the check for a pending irq is already done.



16/8/2012

I had a look into the 'do_event_work_cb' issue. The best way to handle this
seems to be the 'bsp_interrupt_handler_dispatch', as this routine looks up the
vector number in the IDT and returns the right handler. 
Now I just need to find out, where the IRQ number is stored by l4vcpu.
The number is still where it belongs. The pending irq flag just tells, there is
a IRQ to read, please read it. The handler should read it and pass the right
number on to the dispatch function in RTEMS. Further on the interrupt controler
will be customised. Which provides us with access to the IDT seen by RTEMS.

The __l4sys_invoke_direct address has to be written into the linker as a
definition. As the number is fixed in x86 it can be a hard coded magic number.

So far I added a PROVIDE in the linkcmds in libbsp/l4vcpu/pc386/startup/ for
the __l4sys_invoke_direct and hardcoded the magic number for the x86 platform.
Additionaly I fixed the wrapper_1.cc/.h files.
It compiles all the samples, but when I load the hello-sample into the l4vcpu
environment, it traps when starting _load_segemnts in pc386/startup/ldsegs.S.



17/08/2012

The trap was due to a general protection fault, as RTEMS tries to set up the
GDT and IDT, including CS and DS. All this can only be done by the kernel in
ring 0, so it raises a general protection fault.
As fiasco already dealt with this, we have no need for this, and can jump right
to the next step. 



20/08/2012

Next: UTCB access crashes and I need to setup a BIOS like environment, so RTEMS
can read VIDEO_MODE_ADDR and possibly some other values too.
Well, ignore the VIDEO_MODE_ADDR stuff in IBMPC_initVideo and use uart or serial.



21/08/2012
The UTCB access might not be the problem. I discovered a mov operation moving a
value to eax, which moves a zero or nothing. So this might be the real problem.



22/08/2012
The missing value is my sharedVariableStruct, which contains the pointer to the
vcpu for interrupt handling. This value is stored in %edx by the wrapper and
should be read by the bootcode of RTEMS. But it's still ZERO after the
operation. 
After initializing the sharedVariableStruct in RTEMS with 1 instead of 0 the
addres changed and it magically worked. If you initialize with 0 it is moved to
the .bss segment, if initalized with 1 somewhere else. This is really hacky
stuff, but it works.

++++ TODO +++++ The wrapper code of the main function needs to be structured.
It's all messy.
++++ DONE +++++

The execution of the RTEMS_Guest stopps, when RTEMS tries to initialize the
timer, because the 'inport' and 'outport' routines aren't handled yet. I added
l4rtems_inport/outport to the wrapper and modified
i386_inport_byte/word/long and i386_outport_byte/word/long with a call to
l4rtems_{in/out}port.



23/08/2012
I added my library functions to rtems with 'ar r librtemscpu.a libl4rtems.o.a'.
That is very hacky, but I haven't found the right way to place an additional
library in the rtems build. This introduced another phdr into the elf file of
the hello-sample with the type GNU_STACK. At the moment I simply ignore it and
it seems to work.

++++ TODO ++++ Find a way to add libraries to RTEMS.
++++ TODO ++++ Modify wrapper.cc::load_elf() function to load more than one
phdr.

I have to give the in/out-port thingy a second look, as the pending operation
tries to send data to a port. I think I need to grab a capability for this port
first.
So the inport/outport methods have to keep track of the port-capabilities and
aquire a new one, if they don't have it.


24/08/2012
Timer: Either I write a virtual interface for the hardware timer or I write a
software timer for RTEMS and adjust the RTEMS code.
The port stuff, should throw a GPF, as the Task doesn't have the rights to
write to that port, but it doesn't.

Console: I have a growing need of initalizing a console to get some debugging
output directly from the RTEMS guest.

IDT: The rtems_irq_mngt_init fails, as we didn't set a IDT.


30/08/2012
The l4rtems_timer got a default period of 1ms, but the caller is able to
define it's own period length in milliseconds <ms>. Default was chosen due to
the call to 'calibrate 1ms loop' function at RTEMS startup.

=== Console
The sharedVariableStruct gets extended to pass the framebuffer parameters to
RTEMS, which are needed to initialize the RTEMS console. The initVideo routine
was rewritten and tailored to virtual interface.

I did some adaptions in the outch.c file, to support 'unsigned long' datatypes
(less casting) and some followup rewrite in videoAsm.S to ensure these changes
don't cause problems. (Need somebody to check the asm code!)

In start.S I replaced the call to _IBMPC_initVideo with my _L4RTEMS_initVideo
and it looks like the sharedVariableStruct doesn't store the pointer - again.
Maybe this is due to the additional tasks running to provide IO and framebuffer
functionality, but I am not sure. 

The wrapper initializes a goos_fb and stores the necessary values in the
guestHostStruct.


31/08/2012
Thanks to Björn, I discovered my fault. I dereferenced the pointer not often
enough, I fixed it by storing the pointer to the datastructure in EDX and not
the pointer to the pointer to the datastructure.. .
Following nice output in the framebuffer the 'wr_curser' method brings
problems, as it wants to talk to outports. But the framebuffer is handled by
L4Re and so I need to replace it.

== Console
Easy way: just reroute the output to l4re and let it handle the printing.
Difficult way: Fiddle with the framebuffer and work with the disadvantages.
Choose: Easy way! ==> wr_curser stuff unnecessary

== IDT
Hardware IDT isn't necessary, only the stuff that sets up the table in
software, so the handler can address it. So give the rtems_irq_mngt_init a
closer look.

== Handler
Needs to move into RTEMS, for effective IRQ handling.

== Timer IRQ
Works, but as interrupts are disabled, there is no current use.

++++ TODO ++++ interrupts.h
  replace the NULL parts in l4vcpu_irq_restore!



03/09/2012
== Console
Third way: use serial interface / uart.

== Interrupt extension
RTEMS has an interrupt abstraction layer, called 'interrupt extension' defined
in libbsp/shared/include/irq-generic.h . There are the needs for minimal IRQ
handling defined. 

I removed all hardware related interrupt init code in shared/irq/irq-init.c 
and hope,there is no direct call from the higher level code to these entries.
Well, there is an outport call at BSP_irq_enable_at_i8259s, so this can't work
yet. But apart from this, it looks fine.

== bsp_start_default
killed PCI and IDE init, as it is unnecessary right now. I need to get the
interrupt stuff working first.
It works!
Back at the boot_card startup sequence, the
bootcard_bsp_libc_helper/bsp_libc_init function is causing trouble. It calls
RTEMS_Malloc_Initialize but on the way it crashes into an unhandled 'cli'
instruction. I have no idea how it gets there, at the moment, but now I fix the
printk output.



06/09/2012
== RTEMS_Malloc_Initialize
Fixed! The multiboot structure was filled with bogus numbers, so the numbers
read from it were wrong. With the current ones, I get reasonable results and
the init process advances to the keyboard driver.

== Console output:
Still no printk support, as I have no clue how to get the stdin file descriptor
inside of RTEMS. Maybe the serial bus is the way to go, but I need to read on 
this first. 

++++ TODO ++++ Fix the IDT setup.


07/09/2012
I am passing the l4 stdin/out file descriptors in the sharedVarStruct. Printk
works without error, but also without output.. .
For everything else I have to advance the interrupt handling first.

=== Educated guess
- Request every IRQ nbr, RTEMS has a handler for. So far:
    #define BSP_PERIODIC_TIMER    0
    #define BSP_KEYBOARD          1
    #define BSP_UART_COM2_IRQ	  3
    #define BSP_UART_COM1_IRQ	  4
    #define BSP_RT_TIMER1	  8
    #define BSP_RT_TIMER3	  10
- attach/detach RTEMS thread to these IRQs, when 
    bsp_interrupt_handler_install/remove is called.
- triggered IRQ forces vcpu_exit, an handler_entry and the  handler calls
    rtems_interrupt_handler_dispatch with the irq nbr.
- provide replacement for BSP_irq_enable/disable_at_i8259s
- ++OR++ provide replacement for bsp_interrupt_vector_enable/disable and make
    sure nobody wants to use BSP_irq_enable/disable_at_i8259s.

2nd step
-- handler then tries to read from in/out_port, which needs to be done through
    L4Re!?

I marked the points in l4vcpu/irq.c, where the L4Re wrapper communication is
necessary.


10/09/2012
Added the L4 routines for attaching and detaching IRQs.
Restructured the RTEMS_wrapper files: Moved a lot of code into the now C++
library.


13/09/2012
Incrementally linked libl4rtems.a without loose ends.
Still problems with output routing.


20/09/2012
L4linux and l4openbsd use a L4_EXTERNAL_FUNC routine and together with
__l4_external_resolver. To provide an interface for functions running in the
host to the guest.


27/09/2012
Next approach on the printing issue. I use an additional thread to print
everything, that's written to a shared buffer by RTEMS. The buffer and a flag
is passed in the sharedVariableStructure.
??? How do I pass arguments to l4_threads? Atm I worked around it with global
vars.

++++ TODO ++++ Add atomic compare and swap to deal with the shared flag.
--> preliminary solution: nobody can write to the buffer, before the buffer 
is written to the output

Removed some of the incrementally linked libraries, as they cause trouble.
Comment out some of my library code, too, to postpone the undefined reference
errors.

::::OUTPUT ISSUE:::: Got output with the output thread polling on the flag. 
DRAWBACKS: 
- Spinning while the output isn't consumed by l4rtems_buffOut;
- Bad performance

The spinning stuff doesn't work, as the loop never exits. Don't know why.

=== Configuration: rtmes_configuration_table
I need to find this table and how it is set up. My read is, this is done at
compile time, when the macros get evaluated. If I can get a hold on the drivers
needed for startup (keyboard, ...), I can reason about the virtualization 
design. I think this way is better than taking a driver by driver approach.

The keyboard get's initialized together with the console in console.c.
Ignoring this, leads to an error in threadhandler.c, due to an sti instruction.
I tried to change it to i386_interrupt_enable/disable but this leads to a ton
of compile errors.
