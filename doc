Testing the cross compiler with the test mentioned in getting started pdf works

Added symbolic links from l4vcpu-rtems4.11-* to i386-rtems4.11-* in
/opt/rtems-4.11/bin

Added l4vcpu in c/src/aclocal/rtems-cpu-subdirs.m4

Added l4vcpu in config.sub

--- above is critical -- 



Added symbolic link to wrapper_1.h in back_rtems/cpukit/score/cpu/l4vcpu/rtems/score/ and added the include in 'interrupts.h' in the same folder

Added wrapper_1.h file mentioned above in cpukit/score/cpu/l4vcpu/Makefile.am

--enable-maintainer-mode :
  Makefile.am changes will be written out to Makefile.in

add libl4rtems.a.o to l4vcpu-rtems4.11/pc386/lib/
results in more specific `undefined reference` errors

+++ TODO +++

  add in the l4 header files to complete the compile process!
    The cpukit/score/cpu/l4vcpu/rtems/l4 folder has to be created with an extra
      command. Or the make process will fail with 'no file or directory'.
      Or, the wrapper needs to be moved to ../l4vcpu/rtems/score/
    The include paths for the wrapper need to be fixed, so it can be cleanly
      included.


08/07/2012
The libl4rtems.o.a library needs to be linked completly in the l4 environment,
so there are no Undefined symbols left in the symbol table. 
There are various ways I to achieve this, but I don't know which one will work,
so I just list them:
* -z defs  //if shared_library undef symbols still allowed
// if shared:
* -Bstatic ++ -shared ++ --unresolved-symbols=report-all
* -Bsymbolic


WTF Moment of the hour!
src/l4/mk/lib.mk:78  :: LDSCRIPT_INCR ?= /dev/null
  so actually we do NOT have a incremental linker script? 


09/07/2012
l4rtems_outport / _inport / _out / _in
  * needs implementation
  * hooks in /c/src/lib/libcpu/l4vcpu/cpu.h
  => put impl in the library file or in the wrapper?

l4rtems_irq_restore / ++
  * implemented in wrapper_1.h but 'undefined reference' error
  => put impl in the library file? 
    * But functionality of the wrapper needed
    * How can I add the wrapper to the libl4rtems library?


10/07/2012

moving l4rtems_irq_disable_save as a dummy function to libl4rtems/l4rtems_io.c
and adding the function name to global.syms solves the undefined references,
but I can't use it there, because the l4_vcpu_state_t needs to be in the
wrapper_1.c file. I need to structure the code, so I can provide a library to
rtems and run it on l4re --> THinK!


12/07/2012

Through which interface does the vCPU-Guest (RTEMS) and the vCPU-Host (L4Re)
communicate?
When I link staticaly the l4rtems.o.a into RTEMS, I don't get the address of
my L4Re code. I get the address of the code linked into RTEMS and this code
doesn't have a connection to L4Re anymore. So how do I implement the vcpu-exit,
which is caught by the vCPU-handler on the host system?
Where do I place the exit reason? --> is_irq_entry() ->i()->label


What I should do:
Define a structure in L4Re to share with RTEMS during startup. To do this,
store the pointer to the structure in a vCPU register. As we are in the same
address space this works fine. I just have to include the libvcpu-header file,
so RTEMS knows the structure of the vCPU. As the shared structure grows, I have
to include more headers. But we will see that when the time is right.


14/12/2012

I added a shared variable structure to the RTEMS_wrapper and stored it in edx
of the vCPU. I isn't used in start.S directly and I hope I can extract the
pointer to this shared structure in bootcard with a litte bit of inline asm. 
But bootcard is shared over all BSPs so specific changes for one bsp should
NOT go in there.
It would be best practice to declare the sharedVar variable somewhere inside
the l4vcpuBsp and save the pointer at the beginning of the start.S file, as
this is BSP specific. How do I declare extern variables in ASM? Just with
"EXTERN _varname" or does this only work for functions?
And the second question is, where to store the variable in the first place.
Maybe it would be best to write a special file.

I already added custome functions for inport/outport in 
c/src/lib/libcpu/l4vcpu/cpu.h. I copied the old i386 methods back, so I can
focus on a more specific set of problems without side effects from linker
errors.
Result: Only a few 'undefined reference' errors remain

I removed the previously added libl4rtems.o.a from the build dir.
I also removed l4rtems_inch/_ouch from libbsp/l4vcpu/pc386/console/console.c
Now onyle the 'undefined reference to irq_disable/endable' errors remain.

I placed the sharedVariableStruct together with the wrapper_1.h include in the
pc386/startup/bspgeworkarea.c file and defined it extern in start/start.S.
==> I have a include problem, so the sharedvars_t is not recognised. 


15/07/2012

First thing on a sunday morning: 'typedef' seems to be a C++ construct and is
not recognized by RTEMS. I exchanged it with 'struct guestHostShare. Now it
compiles fine.

Now I move libvcpu/include/vcpu.h into the cpukit/score/rtems/l4vcpu tree and
include it in interrupts.h, as I need it for the enable/disable interrupt
functionality.
Due to this change I need all l4 dependencies in the RTEMS tree, which I
modified to only search for local headers and prefixed all with l4, so they
don't collide with RTEMS includes.
So now I got a complete set of necessary l4 includes, mostly from l4sys and
l4sys/ARCH_x86. I added and modified the includes of all files; l4utcb.h and
l4utcb_x86.h have been a bit tricky, as they depend on each other and the compiler
doesn't overwrite weak declarations. Additionally the l4_utcb_t is not found in
l4utcb_x86.h, so I copied it over.

Some errors bound to the change in interrupts.h still remain. 
>> error: dereferencing pointer to incomplete type
I think the declaration: 'extern struct guestHostShare *sharedVariableStruct'
is not working correctly. 

I needed to add the wrapper.h to the interrupts.h file and to include vcpu.h in
the wrapper.h.
I don't know how to handle the last two parameters of 'l4vcpu_irq_restore' -
'do_event_work_cb' and 'setup_ipc'. I just work with NULL for both of them, to keep
going.

Moved the 'l4rtems_vcpu_irq_state' to 'getbspworkarea.c' and declared it as
'extern' in interrupts.h, as it throws multiple definition errors.

And the added NULL value for 'setup_ipc' and 'do_event_work_cb' is already
falling on my feet...


16/07/2012

No it wasn't. The undefined reference to l4_ipc_wait was due to the missing
implementation file, as it's an architecture specific file. Additionally I need
to remove the header of l4_ipc_wait in l4ipc.h and add the include of
l4ipc-invoke-x86.h and l4ipc-l42-gcc3-nopic.h(order matters). 
This leads to an undefined reference of __l4sys_invoke_direct, which should be
provided by the linker itself in the linkerscript. 
L4Re provides it in ldscripts/generic.h as __l4sys_invoke_direct =
__L4_KIP_ADDR__ + 0x800. The __L4_KIP_ADDR__ is provided by the buildsystem in
l4/mk/prog.mk, which grabs the variable from l4/mk/Makeconf.
>> The question is: How do I get this address into RTEMS?


I need to implement the 'do_event_work_cb' and it should point to the RTEMS irq
handler, as the check for a pending irq is already done.



16/8/2012

I had a look into the 'do_event_work_cb' issue. The best way to handle this
seems to be the 'bsp_interrupt_handler_dispatch', as this routine looks up the
vector number in the IDT and returns the right handler. 
Now I just need to find out, where the IRQ number is stored by l4vcpu.
The number is still where it belongs. The pending irq flag just tells, there is
a IRQ to read, please read it. The handler should read it and pass the right
number on to the dispatch function in RTEMS. Further on the interrupt controler
will be customised. Which provides us with access to the IDT seen by RTEMS.

The __l4sys_invoke_direct address has to be written into the linker as a
definition. As the number is fixed in x86 it can be a hard coded magic number.

So far I added a PROVIDE in the linkcmds in libbsp/l4vcpu/pc386/startup/ for
the __l4sys_invoke_direct and hardcoded the magic number for the x86 platform.
Additionaly I fixed the wrapper_1.cc/.h files.
It compiles all the samples, but when I load the hello-sample into the l4vcpu
environment, it traps when starting _load_segemnts in pc386/startup/ldsegs.S.



17/08/2012

The trap was due to a general protection fault, as RTEMS tries to set up the
GDT and IDT, including CS and DS. All this can only be done by the kernel in
ring 0, so it raises a general protection fault.
As fiasco already dealt with this, we have no need for this, and can jump right
to the next step. 



20/08/2012

Next: UTCB access crashes and I need to setup a BIOS like environment, so RTEMS
can read VIDEO_MODE_ADDR and possibly some other values too.
Well, ignore the VIDEO_MODE_ADDR stuff in IBMPC_initVideo and use uart or serial.



21/08/2012
The UTCB access might not be the problem. I discovered a mov operation moving a
value to eax, which moves a zero or nothing. So this might be the real problem.



22/08/2012
The missing value is my sharedVariableStruct, which contains the pointer to the
vcpu for interrupt handling. This value is stored in %edx by the wrapper and
should be read by the bootcode of RTEMS. But it's still ZERO after the
operation. 
After initializing the sharedVariableStruct in RTEMS with 1 instead of 0 the
addres changed and it magically worked. If you initialize with 0 it is moved to
the .bss segment, if initalized with 1 somewhere else. This is really hacky
stuff, but it works.


