Testing the cross compiler with the test mentioned in getting started pdf works

Added symbolic links from l4vcpu-rtems4.11-* to i386-rtems4.11-* in
/opt/rtems-4.11/bin

Added l4vcpu in c/src/aclocal/rtems-cpu-subdirs.m4

Added l4vcpu in config.sub

--- above is critical -- 



Added symbolic link to wrapper_1.h in back_rtems/cpukit/score/cpu/l4vcpu/rtems/score/ and added the include in 'interrupts.h' in the same folder

Added wrapper_1.h file mentioned above in cpukit/score/cpu/l4vcpu/Makefile.am

--enable-maintainer-mode :
  Makefile.am changes will be written out to Makefile.in

add libl4rtems.a.o to l4vcpu-rtems4.11/pc386/lib/
results in more specific `undefined reference` errors

+++ TODO +++

  add in the l4 header files to complete the compile process!
    The cpukit/score/cpu/l4vcpu/rtems/l4 folder has to be created with an extra
      command. Or the make process will fail with 'no file or directory'.
      Or, the wrapper needs to be moved to ../l4vcpu/rtems/score/
    The include paths for the wrapper need to be fixed, so it can be cleanly
      included.


08/07/2012
The libl4rtems.o.a library needs to be linked completly in the l4 environment,
so there are no Undefined symbols left in the symbol table. 
There are various ways I to achieve this, but I don't know which one will work,
so I just list them:
* -z defs  //if shared_library undef symbols still allowed
// if shared:
* -Bstatic ++ -shared ++ --unresolved-symbols=report-all
* -Bsymbolic


WTF Moment of the hour!
src/l4/mk/lib.mk:78  :: LDSCRIPT_INCR ?= /dev/null
  so actually we do NOT have a incremental linker script? 


09/07/2012
l4rtems_outport / _inport / _out / _in
  * needs implementation
  * hooks in /c/src/lib/libcpu/l4vcpu/cpu.h
  => put impl in the library file or in the wrapper?

l4rtems_irq_restore / ++
  * implemented in wrapper_1.h but 'undefined reference' error
  => put impl in the library file? 
    * But functionality of the wrapper needed
    * How can I add the wrapper to the libl4rtems library?


10/07/2012

moving l4rtems_irq_disable_save as a dummy function to libl4rtems/l4rtems_io.c
and adding the function name to global.syms solves the undefined references,
but I can't use it there, because the l4_vcpu_state_t needs to be in the
wrapper_1.c file. I need to structure the code, so I can provide a library to
rtems and run it on l4re --> THinK!


12/07/2012

Through which interface does the vCPU-Guest (RTEMS) and the vCPU-Host (L4Re)
communicate?
When I link staticaly the l4rtems.o.a into RTEMS, I don't get the address of
my L4Re code. I get the address of the code linked into RTEMS and this code
doesn't have a connection to L4Re anymore. So how do I implement the vcpu-exit,
which is caught by the vCPU-handler on the host system?
Where do I place the exit reason? --> is_irq_entry() ->i()->label


What I should do:
Define a structure in L4Re to share with RTEMS during startup. To do this,
store the pointer to the structure in a vCPU register. As we are in the same
address space this works fine. I just have to include the libvcpu-header file,
so RTEMS knows the structure of the vCPU. As the shared structure grows, I have
to include more headers. But we will see that when the time is right.


14/12/2012

I added a shared variable structure to the RTEMS_wrapper and stored it in edx
of the vCPU. I isn't used in start.S directly and I hope I can extract the
pointer to this shared structure in bootcard with a litte bit of inline asm. 
I need to share the layout of the structure too, otherwise the access is just
messy. So I just include the wrapper_1.h file.
