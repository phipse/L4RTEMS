=== NOTE ===
Dates are written as DD/MM/YYYY
============


Testing the cross compiler with the test mentioned in getting started pdf works

Added symbolic links from l4vcpu-rtems4.11-* to i386-rtems4.11-* in
/opt/rtems-4.11/bin

Added l4vcpu in c/src/aclocal/rtems-cpu-subdirs.m4

Added l4vcpu in config.sub around line 319, to the "i*86 | x86_64" option

--- above is critical -- 



Added symbolic link to wrapper_1.h in 
back_rtems/cpukit/score/cpu/l4vcpu/rtems/score/ 
and added the include in 'interrupts.h' in the same folder

Added wrapper_1.h file mentioned above in cpukit/score/cpu/l4vcpu/Makefile.am

--enable-maintainer-mode :
  Makefile.am changes will be written out to Makefile.in

add libl4rtems.a.o to l4vcpu-rtems4.11/pc386/lib/
results in more specific `undefined reference` errors

+++ TODO +++

  add in the l4 header files to complete the compile process!
    The cpukit/score/cpu/l4vcpu/rtems/l4 folder has to be created with an extra
      command. Or the make process will fail with 'no file or directory'.
      Or, the wrapper needs to be moved to ../l4vcpu/rtems/score/
    The include paths for the wrapper need to be fixed, so it can be cleanly
      included.
--- DONE ---      


08/07/2012
The libl4rtems.o.a library needs to be linked completly in the l4 environment,
so there are no Undefined symbols left in the symbol table. 
There are various ways I to achieve this, but I don't know which one will work,
so I just list them:
* -z defs  //if shared_library undef symbols still allowed
// if shared:
* -Bstatic ++ -shared ++ --unresolved-symbols=report-all
* -Bsymbolic


WTF Moment of the hour!
src/l4/mk/lib.mk:78  :: LDSCRIPT_INCR ?= /dev/null
  so actually we do NOT have a incremental linker script? 


09/07/2012
l4rtems_outport / _inport / _out / _in
  * needs implementation
  * hooks in /c/src/lib/libcpu/l4vcpu/cpu.h
  => put impl in the library file or in the wrapper?

l4rtems_irq_restore / ++
  * implemented in wrapper_1.h but 'undefined reference' error
  => put impl in the library file? 
    * But functionality of the wrapper needed
    * How can I add the wrapper to the libl4rtems library?


10/07/2012

moving l4rtems_irq_disable_save as a dummy function to libl4rtems/l4rtems_io.c
and adding the function name to global.syms solves the undefined references,
but I can't use it there, because the l4_vcpu_state_t needs to be in the
wrapper_1.c file. I need to structure the code, so I can provide a library to
rtems and run it on l4re --> THinK!


12/07/2012

Through which interface does the vCPU-Guest (RTEMS) and the vCPU-Host (L4Re)
communicate?
When I link staticaly the l4rtems.o.a into RTEMS, I don't get the address of
my L4Re code. I get the address of the code linked into RTEMS and this code
doesn't have a connection to L4Re anymore. So how do I implement the vcpu-exit,
which is caught by the vCPU-handler on the host system?
Where do I place the exit reason? --> is_irq_entry() ->i()->label


What I should do:
Define a structure in L4Re to share with RTEMS during startup. To do this,
store the pointer to the structure in a vCPU register. As we are in the same
address space this works fine. I just have to include the libvcpu-header file,
so RTEMS knows the structure of the vCPU. As the shared structure grows, I have
to include more headers. But we will see that when the time is right.


14/12/2012

I added a shared variable structure to the RTEMS_wrapper and stored it in edx
of the vCPU. I isn't used in start.S directly and I hope I can extract the
pointer to this shared structure in bootcard with a litte bit of inline asm. 
But bootcard is shared over all BSPs so specific changes for one bsp should
NOT go in there.
It would be best practice to declare the sharedVar variable somewhere inside
the l4vcpuBsp and save the pointer at the beginning of the start.S file, as
this is BSP specific. How do I declare extern variables in ASM? Just with
"EXTERN _varname" or does this only work for functions?
And the second question is, where to store the variable in the first place.
Maybe it would be best to write a special file.

I already added custome functions for inport/outport in 
c/src/lib/libcpu/l4vcpu/cpu.h. I copied the old i386 methods back, so I can
focus on a more specific set of problems without side effects from linker
errors.
Result: Only a few 'undefined reference' errors remain

I removed the previously added libl4rtems.o.a from the build dir.
I also removed l4rtems_inch/_ouch from libbsp/l4vcpu/pc386/console/console.c
Now onyle the 'undefined reference to irq_disable/endable' errors remain.

I placed the sharedVariableStruct together with the wrapper_1.h include in the
pc386/startup/bspgeworkarea.c file and defined it extern in start/start.S.
==> I have a include problem, so the sharedvars_t is not recognised. 


15/07/2012

First thing on a sunday morning: 'typedef' seems to be a C++ construct and is
not recognized by RTEMS. I exchanged it with 'struct guestHostShare. Now it
compiles fine.

Now I move libvcpu/include/vcpu.h into the cpukit/score/rtems/l4vcpu tree and
include it in interrupts.h, as I need it for the enable/disable interrupt
functionality.
Due to this change I need all l4 dependencies in the RTEMS tree, which I
modified to only search for local headers and prefixed all with l4, so they
don't collide with RTEMS includes.
So now I got a complete set of necessary l4 includes, mostly from l4sys and
l4sys/ARCH_x86. I added and modified the includes of all files; l4utcb.h and
l4utcb_x86.h have been a bit tricky, as they depend on each other and the compiler
doesn't overwrite weak declarations. Additionally the l4_utcb_t is not found in
l4utcb_x86.h, so I copied it over.

Some errors bound to the change in interrupts.h still remain. 
>> error: dereferencing pointer to incomplete type
I think the declaration: 'extern struct guestHostShare *sharedVariableStruct'
is not working correctly. 

I needed to add the wrapper.h to the interrupts.h file and to include vcpu.h in
the wrapper.h.
I don't know how to handle the last two parameters of 'l4vcpu_irq_restore' -
'do_event_work_cb' and 'setup_ipc'. I just work with NULL for both of them, to keep
going.

Moved the 'l4rtems_vcpu_irq_state' to 'getbspworkarea.c' and declared it as
'extern' in interrupts.h, as it throws multiple definition errors.

And the added NULL value for 'setup_ipc' and 'do_event_work_cb' is already
falling on my feet...


16/07/2012

No it wasn't. The undefined reference to l4_ipc_wait was due to the missing
implementation file, as it's an architecture specific file. Additionally I need
to remove the header of l4_ipc_wait in l4ipc.h and add the include of
l4ipc-invoke-x86.h and l4ipc-l42-gcc3-nopic.h(order matters). 
This leads to an undefined reference of __l4sys_invoke_direct, which should be
provided by the linker itself in the linkerscript. 
L4Re provides it in ldscripts/generic.h as __l4sys_invoke_direct =
__L4_KIP_ADDR__ + 0x800. The __L4_KIP_ADDR__ is provided by the buildsystem in
l4/mk/prog.mk, which grabs the variable from l4/mk/Makeconf.
>> The question is: How do I get this address into RTEMS?


I need to implement the 'do_event_work_cb' and it should point to the RTEMS irq
handler, as the check for a pending irq is already done.



16/8/2012

I had a look into the 'do_event_work_cb' issue. The best way to handle this
seems to be the 'bsp_interrupt_handler_dispatch', as this routine looks up the
vector number in the IDT and returns the right handler. 
Now I just need to find out, where the IRQ number is stored by l4vcpu.
The number is still where it belongs. The pending irq flag just tells, there is
a IRQ to read, please read it. The handler should read it and pass the right
number on to the dispatch function in RTEMS. Further on the interrupt controler
will be customised. Which provides us with access to the IDT seen by RTEMS.

The __l4sys_invoke_direct address has to be written into the linker as a
definition. As the number is fixed in x86 it can be a hard coded magic number.

So far I added a PROVIDE in the linkcmds in libbsp/l4vcpu/pc386/startup/ for
the __l4sys_invoke_direct and hardcoded the magic number for the x86 platform.
Additionaly I fixed the wrapper_1.cc/.h files.
It compiles all the samples, but when I load the hello-sample into the l4vcpu
environment, it traps when starting _load_segemnts in pc386/startup/ldsegs.S.



17/08/2012

The trap was due to a general protection fault, as RTEMS tries to set up the
GDT and IDT, including CS and DS. All this can only be done by the kernel in
ring 0, so it raises a general protection fault.
As fiasco already dealt with this, we have no need for this, and can jump right
to the next step. 



20/08/2012

Next: UTCB access crashes and I need to setup a BIOS like environment, so RTEMS
can read VIDEO_MODE_ADDR and possibly some other values too.
Well, ignore the VIDEO_MODE_ADDR stuff in IBMPC_initVideo and use uart or serial.



21/08/2012
The UTCB access might not be the problem. I discovered a mov operation moving a
value to eax, which moves a zero or nothing. So this might be the real problem.



22/08/2012
The missing value is my sharedVariableStruct, which contains the pointer to the
vcpu for interrupt handling. This value is stored in %edx by the wrapper and
should be read by the bootcode of RTEMS. But it's still ZERO after the
operation. 
After initializing the sharedVariableStruct in RTEMS with 1 instead of 0 the
addres changed and it magically worked. If you initialize with 0 it is moved to
the .bss segment, if initalized with 1 somewhere else. This is really hacky
stuff, but it works.

++++ TODO ++++ The wrapper code of the main function needs to be structured.
It's all messy.
---- DONE ----

The execution of the RTEMS_Guest stopps, when RTEMS tries to initialize the
timer, because the 'inport' and 'outport' routines aren't handled yet. I added
l4rtems_inport/outport to the wrapper and modified
i386_inport_byte/word/long and i386_outport_byte/word/long with a call to
l4rtems_{in/out}port.



23/08/2012
I added my library functions to rtems with 'ar r librtemscpu.a libl4rtems.o.a'.
That is very hacky, but I haven't found the right way to place an additional
library in the rtems build. This introduced another phdr into the elf file of
the hello-sample with the type GNU_STACK. At the moment I simply ignore it and
it seems to work.

++++ TODO ++++ 
Find a way to add libraries to RTEMS.
---- Done ---- 

++++ TODO ++++ 
Modify wrapper.cc::load_elf() function to load more than one phdr.

I have to give the in/out-port thingy a second look, as the pending operation
tries to send data to a port. I think I need to grab a capability for this port
first.
So the inport/outport methods have to keep track of the port-capabilities and
aquire a new one, if they don't have it.


24/08/2012
Timer: Either I write a virtual interface for the hardware timer or I write a
software timer for RTEMS and adjust the RTEMS code.
The port stuff, should throw a GPF, as the Task doesn't have the rights to
write to that port, but it doesn't.

Console: I have a growing need of initalizing a console to get some debugging
output directly from the RTEMS guest.

IDT: The rtems_irq_mngt_init fails, as we didn't set a IDT.


30/08/2012
The l4rtems_timer got a default period of 1ms, but the caller is able to
define it's own period length in milliseconds <ms>. Default was chosen due to
the call to 'calibrate 1ms loop' function at RTEMS startup.

=== Console
The sharedVariableStruct gets extended to pass the framebuffer parameters to
RTEMS, which are needed to initialize the RTEMS console. The initVideo routine
was rewritten and tailored to virtual interface.

I did some adaptions in the outch.c file, to support 'unsigned long' datatypes
(less casting) and some followup rewrite in videoAsm.S to ensure these changes
don't cause problems. (Need somebody to check the asm code!)

In start.S I replaced the call to _IBMPC_initVideo with my _L4RTEMS_initVideo
and it looks like the sharedVariableStruct doesn't store the pointer - again.
Maybe this is due to the additional tasks running to provide IO and framebuffer
functionality, but I am not sure. 

The wrapper initializes a goos_fb and stores the necessary values in the
guestHostStruct.


31/08/2012
Thanks to BjÃ¶rn, I discovered my fault. I dereferenced the pointer not often
enough, I fixed it by storing the pointer to the datastructure in EDX and not
the pointer to the pointer to the datastructure.. .
Following nice output in the framebuffer the 'wr_curser' method brings
problems, as it wants to talk to outports. But the framebuffer is handled by
L4Re and so I need to replace it.

== Console
Easy way: just reroute the output to l4re and let it handle the printing.
Difficult way: Fiddle with the framebuffer and work with the disadvantages.
Choose: Easy way! ==> wr_curser stuff unnecessary

== IDT
Hardware IDT isn't necessary, only the stuff that sets up the table in
software, so the handler can address it. So give the rtems_irq_mngt_init a
closer look.

== Handler
Needs to move into RTEMS, for effective IRQ handling.

== Timer IRQ
Works, but as interrupts are disabled, there is no current use.

++++ TODO ++++ interrupts.h
  replace the NULL parts in l4vcpu_irq_restore!
---- DONE ----



03/09/2012
== Console
Third way: use serial interface / uart.

== Interrupt extension
RTEMS has an interrupt abstraction layer, called 'interrupt extension' defined
in libbsp/shared/include/irq-generic.h . There are the needs for minimal IRQ
handling defined. 

I removed all hardware related interrupt init code in shared/irq/irq-init.c 
and hope,there is no direct call from the higher level code to these entries.
Well, there is an outport call at BSP_irq_enable_at_i8259s, so this can't work
yet. But apart from this, it looks fine.

== bsp_start_default
killed PCI and IDE init, as it is unnecessary right now. I need to get the
interrupt stuff working first.
It works!
Back at the boot_card startup sequence, the
bootcard_bsp_libc_helper/bsp_libc_init function is causing trouble. It calls
RTEMS_Malloc_Initialize but on the way it crashes into an unhandled 'cli'
instruction. I have no idea how it gets there, at the moment, but now I fix the
printk output.



06/09/2012
== RTEMS_Malloc_Initialize
Fixed! The multiboot structure was filled with bogus numbers, so the numbers
read from it were wrong. With the current ones, I get reasonable results and
the init process advances to the keyboard driver.

== Console output:
Still no printk support, as I have no clue how to get the stdin file descriptor
inside of RTEMS. Maybe the serial bus is the way to go, but I need to read on 
this first. 

++++ TODO ++++ Fix the IDT setup.


07/09/2012
I am passing the l4 stdin/out file descriptors in the sharedVarStruct. Printk
works without error, but also without output.. .
For everything else I have to advance the interrupt handling first.

=== Educated guess
- Request every IRQ nbr, RTEMS has a handler for. So far:
    #define BSP_PERIODIC_TIMER    0
    #define BSP_KEYBOARD          1
    #define BSP_UART_COM2_IRQ	  3
    #define BSP_UART_COM1_IRQ	  4
    #define BSP_RT_TIMER1	  8
    #define BSP_RT_TIMER3	  10
- attach/detach RTEMS thread to these IRQs, when 
    bsp_interrupt_handler_install/remove is called.
- triggered IRQ forces vcpu_exit, an handler_entry and the  handler calls
    rtems_interrupt_handler_dispatch with the irq nbr.
- provide replacement for BSP_irq_enable/disable_at_i8259s
- ++OR++ provide replacement for bsp_interrupt_vector_enable/disable and make
    sure nobody wants to use BSP_irq_enable/disable_at_i8259s.

2nd step
-- handler then tries to read from in/out_port, which needs to be done through
    L4Re!?

I marked the points in l4vcpu/irq.c, where the L4Re wrapper communication is
necessary.


10/09/2012
Added the L4 routines for attaching and detaching IRQs.
Restructured the RTEMS_wrapper files: Moved a lot of code into the now C++
library.



13/09/2012
Incrementally linked libl4rtems.a without loose ends.
Still problems with output routing.



20/09/2012
L4linux and l4openbsd use a L4_EXTERNAL_FUNC routine and together with
__l4_external_resolver. To provide an interface for functions running in the
host to the guest.



27/09/2012
Next approach on the printing issue. I use an additional thread to print
everything, that's written to a shared buffer by RTEMS. The buffer and a flag
is passed in the sharedVariableStructure.
??? How do I pass arguments to l4_threads? Atm I worked around it with global
vars.

++++ TODO ++++ Add atomic compare and swap to deal with the shared flag.
---- DEPRECATED ----
--> preliminary solution: nobody can write to the buffer, before the buffer 
is written to the output

Removed some of the incrementally linked libraries, as they cause trouble.
Comment out some of my library code, too, to postpone the undefined reference
errors.

::::OUTPUT ISSUE:::: Got output with the output thread polling on the flag. 
DRAWBACKS: 
- Spinning while the output isn't consumed by l4rtems_buffOut;
- Bad performance

The spinning stuff doesn't work, as the loop never exits. Don't know why.

=== Configuration: rtmes_configuration_table
I need to find this table and how it is set up. My read is, this is done at
compile time, when the macros get evaluated. If I can get a hold on the drivers
needed for startup (keyboard, ...), I can reason about the virtualization 
design. I think this way is better than taking a driver by driver approach.

The keyboard get's initialized together with the console in console.c.
Ignoring this, leads to an error in threadhandler.c, due to an sti instruction.
I tried to change it to i386_interrupt_enable/disable but this leads to a ton
of compile errors.



1/10/2012
The compile error might be macro related. It disappears, when the one operation
in the if-branch is sourrounded by braces.
Implemented i386_flash_interrupts, but push %(level); popf; cli; doesn't 
necessarily enable interrupts, so my implementation is far away from stable.

Added another thread to provide keyboard input to the guest. Most likely not
the intended behaivour of this kind of virtualization solution, but it's a
first try.
Somehow I end up, at bsp_reset. 
--> At the end of the programm. Yay! But output is missing! 
Well, the output was there, just not there. Printf is directing somewhere else
than printk. So Hello World with printk instead of printf shows everything on
the right console. 



12/10/2012
I extended the sharedVariableStruct with a buffer size variable for the I/O
buffers.
And I redesigned the whole output thing. I don't need an output thread with
busy waiting anymore. A small drawback is the missing color atm.

::: Interesting behaviour
In bspreset.c is a call 'outport_byte(0x64, 0xFE)', which uses the outb
instruction and resets the whole L4 task. I replaced it with a while loop to
prevent the reboot. 
Actually the outb instruction should trigger a general protection fault and
drop into the handler.



15/10/2012
Modified the l4_log_print_srv to l4_vcon_write.
NULL parameters in l4_irq_restore replaced with handler and setup_ipc. 
To achieve this the handler needs to be moved inside of RTEMS.
Moving the handler to a seperate file first and later into the RTEMS.
setup_ipc: empfangsbuffer vorbereiten, nur relevant, wenn man server ist. 
Added l4thread.h and l4util.h to the l4vcpu/rtems/l4vcpu include list and to
the corresponding makefile.
I moved the handler.c into the startup directory of the BSP:
l4vcpu/pc386/startup/ and the handler.h into score/cpu/l4vcpu/rtems/l4vcpu.

Well, seems to work, but the handler can't be invoked, as the address
is currently not read. 
++++ TODO: get the handler IP from the loaded elf file.
---- DEPRECATED!



19/10/2012
To get the IP of the handler, we need to read the symbol table entries, until
we find the right one, but where the heck do I get this entry?
I try to hack my way through the section header table, but it's messy and takes
time.



22/10/2012
Discarded the changes made last time. RTEMS now initializes the vcpu->entry_ip
by itself as soon as start_bsp() is invoked. 
This is safe, because the vcpu starts with disabled IRQs and pagefaults can't
occure, so there won't be an vcpu exit until the entry_ip and therefore the
exception handler is set. 


26/10/2012
Revised the l4rtems_inch function. Now it uses l4_vcon_read to read a whole
buffsize and returns it char by char, until its own buffer is empty. 

I added the pointer to the l4re environment to the shared structure, in order
to gain access to capability allocation. 
++++ TODO
Add l4re_global_env as global variable for the l4re functionality
---- DONE



29/10/2012
I declared a global variable l4re_global_env (IMPORTANT: same name as in l4re!)
and set it in the bspstart routine to the l4re_global_env value passed in the
shared struct.
Unfortunatly the incremental linking process for libl4rtems.o.a already
declared a fixed symbol with that name, hence the l4re routines never used the
rtems-declared one. So I needed to use object files for the incremental linking
instead of full libraries. For details see
l4/pkg/RTEMS_wrapper/lib/src/Makefile.

I implemented a setup_ipc method, which does nothing, just to prevent a NULL
pointer. 
Additionally I am missing timer interrupts in the vcpu. To enable interrupts
the first time, we need a call to l4vcpu_irq_enable, and not .._restore.
After calling irq_enable at the end of the hello world routine, I get endless
handler entries, whose reason I don't know. 
Did bogus. Implemented an extra handleIrq function, to provide as a callback
function to l4vcpu_irq_enable/restore.

Interrupt labels: Nicht die beiden unteren bits verwenden. Nur wenn
Absenderrechte interessant sind, dann anschauen: Maskieren, unmaskieren.


02/11/2012
BEWARE: L4 and RTEMS have different calling conventions for function calls! So
L4 is passing all arguments on the stack and RTEMS awaits some in registers. If
you don't consider this, you might need a lot of time until your tutor comes up
with the idea. 
So I changed the calling conventions of the vcpu exit handler aka
l4rtems_handler to l4_fastcall.


==== INTERMEZZO ====
open TODO from above:
+ Fix the IDT setup.

next step TODO:
+ init keyboard driver
+ get printf working
+ fix the issue with l4vcpu_irq_restore
+ get more examples to work


=== keyboard driver issue ===
We don't need to initialize keyboard hardware. So we can skip that and try to
grab a l4 capability for the keyboard. 
During this try I discovered a fault in my l4rtems_requestIrq implementation,
as I can't attach to the new vector. I am missing l4io_request_irq to get this
working, and this one needs printf. So the printf issue just got boosted in
priority.



09/11/2012
The error of l4io_request_irq seems to come from the missing IO server. I
implemented this one, updated wrapper.cfg and modules.list, added a vbus
configuration, but it still doesn't work.
